Index: app/src/main/java/com/idle/togeduck/util/GPSWorker.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.idle.togeduck.util\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.content.Context\r\nimport android.util.Log\r\nimport androidx.work.CoroutineWorker\r\nimport androidx.work.WorkerParameters\r\nimport com.google.android.gms.location.FusedLocationProviderClient\r\nimport com.google.android.gms.location.LocationServices\r\n\r\nclass GPSWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {\r\n    companion object {\r\n        private val TAG = GPSWorker::class.java.name\r\n    }\r\n\r\n    private val mFusedLocationClient: FusedLocationProviderClient by lazy { \r\n        LocationServices.getFusedLocationProviderClient(context)\r\n    }\r\n    \r\n    @SuppressLint(\"MissingPermission\")\r\n    override suspend fun doWork(): Result {\r\n        return try {\r\n            mFusedLocationClient.lastLocation.addOnCompleteListener { task ->\r\n                if (task.isSuccessful) {\r\n                    Log.d(\"로그\", \"GPSWorker - doWork() 성공 : ${task.result}\")\r\n                } else {\r\n                    Log.d(\"로그\", \"GPSWorker - doWork() 실패 : ${task.result}\")\r\n                }\r\n            }\r\n            Result.success()\r\n        } catch (e: Exception) {\r\n            Log.d(\"로그\", \"GPSWorker - doWork() 에러 : ${e}\")\r\n            Result.failure()\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/idle/togeduck/util/GPSWorker.kt b/app/src/main/java/com/idle/togeduck/util/GPSWorker.kt
--- a/app/src/main/java/com/idle/togeduck/util/GPSWorker.kt	(revision fef057f5fc91674e99d142fb37e781e5ea4564a1)
+++ b/app/src/main/java/com/idle/togeduck/util/GPSWorker.kt	(date 1707960772784)
@@ -7,8 +7,13 @@
 import androidx.work.WorkerParameters
 import com.google.android.gms.location.FusedLocationProviderClient
 import com.google.android.gms.location.LocationServices
+import com.idle.togeduck.network.StompManager
+import javax.inject.Inject
 
 class GPSWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
+
+    @Inject
+    lateinit var stompManager: StompManager
     companion object {
         private val TAG = GPSWorker::class.java.name
     }
@@ -20,11 +25,14 @@
     @SuppressLint("MissingPermission")
     override suspend fun doWork(): Result {
         return try {
-            mFusedLocationClient.lastLocation.addOnCompleteListener { task ->
-                if (task.isSuccessful) {
-                    Log.d("로그", "GPSWorker - doWork() 성공 : ${task.result}")
-                } else {
-                    Log.d("로그", "GPSWorker - doWork() 실패 : ${task.result}")
+            mFusedLocationClient.lastLocation.addOnSuccessListener { location ->
+                if (location != null) {
+                    stompManager.sendLocation(
+                        favoriteSettingViewModel.selectedCelebrity.value?.id ?: 1,
+                        location.latitude,
+                        location.longitude,
+                        mainViewModel.guid!!
+                    )
                 }
             }
             Result.success()
Index: app/src/main/java/com/idle/togeduck/main_map/view/MapFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.idle.togeduck.main_map.view\r\n\r\nimport android.Manifest\r\nimport android.annotation.SuppressLint\r\nimport android.content.pm.PackageManager\r\nimport android.content.res.ColorStateList\r\nimport android.graphics.Bitmap\r\nimport android.graphics.Canvas\r\nimport android.graphics.Color\r\nimport android.graphics.drawable.GradientDrawable\r\nimport android.location.Location\r\nimport android.os.Bundle\r\nimport android.os.Handler\r\nimport android.os.Looper\r\nimport android.util.Log\r\nimport android.view.Gravity\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.FrameLayout\r\nimport android.widget.ImageView\r\nimport android.widget.LinearLayout\r\nimport android.widget.TextView\r\nimport android.widget.Toast\r\nimport androidx.activity.OnBackPressedCallback\r\nimport androidx.constraintlayout.widget.ConstraintLayout\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.fragment.app.activityViewModels\r\nimport androidx.navigation.fragment.findNavController\r\nimport androidx.viewpager2.widget.ViewPager2\r\nimport androidx.work.ExistingPeriodicWorkPolicy\r\nimport androidx.work.PeriodicWorkRequest\r\nimport androidx.work.PeriodicWorkRequestBuilder\r\nimport androidx.work.WorkManager\r\nimport com.google.android.gms.location.FusedLocationProviderClient\r\nimport com.google.android.gms.location.LocationServices\r\nimport com.google.android.material.bottomsheet.BottomSheetBehavior\r\nimport com.google.android.material.materialswitch.MaterialSwitch\r\nimport com.gun0912.tedpermission.PermissionListener\r\nimport com.gun0912.tedpermission.TedPermissionUtil\r\nimport com.gun0912.tedpermission.normal.TedPermission\r\nimport com.idle.togeduck.MainViewModel\r\nimport com.idle.togeduck.QuestType\r\nimport com.idle.togeduck.R\r\nimport com.idle.togeduck.databinding.ComponentBottomAppbarBinding\r\nimport com.idle.togeduck.databinding.ComponentBottomSheetBinding\r\nimport com.idle.togeduck.databinding.FragmentMapBinding\r\nimport com.idle.togeduck.util.CalcStatusBarSize.getStatusBarHeightToDp\r\nimport com.idle.togeduck.util.DpPxUtil.dpToPx\r\nimport com.idle.togeduck.common.ScreenSize.heightPx\r\nimport com.idle.togeduck.common.Theme\r\nimport com.idle.togeduck.di.PreferenceModule\r\nimport com.idle.togeduck.event.EventListViewModel\r\nimport com.idle.togeduck.event.model.Event\r\nimport com.idle.togeduck.favorite.FavoriteSettingViewModel\r\nimport com.idle.togeduck.fcm.FCMData\r\nimport com.idle.togeduck.history.HistoryViewModel\r\nimport com.idle.togeduck.history.model.HistoryTour\r\nimport com.idle.togeduck.history.model.Position\r\nimport com.idle.togeduck.main_map.MapViewModel\r\nimport com.idle.togeduck.main_map.view.map_rv.MapPagerAdapter\r\nimport com.idle.togeduck.network.StompManager\r\nimport com.idle.togeduck.util.CalcDistance\r\nimport com.idle.togeduck.util.GPSWorker\r\nimport com.idle.togeduck.util.NaverItem\r\nimport com.idle.togeduck.util.SnackBarFactory\r\nimport com.idle.togeduck.util.builder\r\nimport com.idle.togeduck.util.getColor\r\nimport com.naver.maps.geometry.LatLng\r\nimport com.naver.maps.map.CameraAnimation\r\nimport com.naver.maps.map.CameraPosition\r\nimport com.naver.maps.map.CameraUpdate\r\nimport com.naver.maps.map.LocationTrackingMode\r\nimport com.naver.maps.map.MapFragment\r\nimport com.naver.maps.map.NaverMap\r\nimport com.naver.maps.map.OnMapReadyCallback\r\nimport com.naver.maps.map.overlay.CircleOverlay\r\nimport com.naver.maps.map.overlay.Marker\r\nimport com.naver.maps.map.overlay.Overlay\r\nimport com.naver.maps.map.overlay.OverlayImage\r\nimport com.naver.maps.map.overlay.PathOverlay\r\nimport com.naver.maps.map.util.FusedLocationSource\r\nimport com.naver.maps.map.util.MarkerIcons\r\nimport dagger.hilt.android.AndroidEntryPoint\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.async\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.datetime.toKotlinLocalDate\r\nimport ted.gun0912.clustering.clustering.algo.NonHierarchicalViewBasedAlgorithm\r\nimport ted.gun0912.clustering.naver.TedNaverClustering\r\nimport java.util.Timer\r\nimport java.util.TimerTask\r\nimport java.util.concurrent.TimeUnit\r\nimport javax.inject.Inject\r\n\r\nenum class EventKind {\r\n    PAST, TODAY, LATER\r\n}\r\n\r\n@AndroidEntryPoint\r\nclass MapFragment : Fragment(), OnMapReadyCallback {\r\n\r\n    private var _binding: FragmentMapBinding? = null\r\n    private val binding get() = _binding!!\r\n    private var _componentBottomSheetBinding: ComponentBottomSheetBinding? = null\r\n    private val componentBottomSheetBinding get() = _componentBottomSheetBinding!!\r\n    private var _componentBottomAppbarBinding: ComponentBottomAppbarBinding? = null\r\n    private val componentBottomAppbarBinding get() = _componentBottomAppbarBinding!!\r\n\r\n    private val mainViewModel: MainViewModel by activityViewModels()\r\n    private val mapViewModel: MapViewModel by activityViewModels()\r\n    private val eventListViewModel: EventListViewModel by activityViewModels()\r\n    private val favoriteSettingViewModel: FavoriteSettingViewModel by activityViewModels()\r\n    private val historyViewModel: HistoryViewModel by activityViewModels()\r\n\r\n    @Inject\r\n    lateinit var stompManager: StompManager\r\n\r\n    private lateinit var naverMap: NaverMap\r\n\r\n    // 최적의 위치를 반환하는 구현체\r\n    private lateinit var locationSource: FusedLocationSource\r\n\r\n    // 현재 위치 가져오기 위한 객체\r\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\r\n\r\n    // OnBackPressedCallback (뒤로가기 기능) 객체 선언\r\n    private lateinit var backPressedCallback: OnBackPressedCallback\r\n\r\n    private lateinit var mapPagerAdapter: MapPagerAdapter\r\n\r\n    private var prevOffset = 0.0f\r\n    private var halfOffset = 0.5f\r\n\r\n    private var clustering: TedNaverClustering<NaverItem>? = null\r\n    private var todayClustering: TedNaverClustering<NaverItem>? = null\r\n    private var upcomingClustering: TedNaverClustering<NaverItem>? = null\r\n    private var pastClustering: TedNaverClustering<NaverItem>? = null\r\n\r\n    private lateinit var sheetBehavior: BottomSheetBehavior<FrameLayout>\r\n\r\n    private var timer: Timer? = null\r\n    private lateinit var workRequest: PeriodicWorkRequest\r\n    private var workManager: WorkManager? = null\r\n\r\n    lateinit var realTimeOnOffBtn :MaterialSwitch\r\n\r\n    private var pathLine: PathOverlay? = null\r\n\r\n    private lateinit var tourStartCircle: GradientDrawable\r\n    private lateinit var tourEndCircle: GradientDrawable\r\n\r\n    @Inject\r\n    lateinit var preference: PreferenceModule\r\n\r\n    private var isHistoryEvent = false\r\n\r\n    /** Fragment Lifecycle Functions **/\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?,\r\n    ): View {\r\n        _binding = FragmentMapBinding.inflate(inflater, container, false)\r\n        _componentBottomSheetBinding = binding.bsFragment\r\n        _componentBottomAppbarBinding = binding.appbar\r\n\r\n        addBackPressedCallback()\r\n\r\n        return binding.root\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        /** 객체 초기화 **/\r\n        super.onViewCreated(view, savedInstanceState)\r\n        realTimeOnOffBtn = binding.realTimeBtn\r\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(requireContext())\r\n\r\n        /** 초기화 관련 함수 호출 **/\r\n        initViewPager()\r\n        initChildFragment()\r\n        setPermissionListener()\r\n        initMapView()\r\n        setBottomSheet()\r\n        setUpBackgroundRoundCorner()\r\n        setUpPeopleNumber()\r\n        setUpBackgroundButtonIcon()\r\n        setUpBottomText()\r\n        setUpFloatingButton()\r\n        setRealTimeContainer()\r\n        setTourBtnTheme()\r\n        initQuestAlert()\r\n\r\n        bottomAppBarClick(1)\r\n\r\n        mapViewModel.initPeopleMarkerImage(initPeopleMarkerImage())\r\n\r\n        mapViewModel.peopleNum.observe(viewLifecycleOwner) {\r\n                number -> binding.mapPeoplecntText.text = \"${number}명의 팬들이 함께하고 있습니다!\"\r\n        }\r\n\r\n        /** 버튼 동작 연결 **/\r\n        realTimeOnOffBtn.setOnClickListener{\r\n            Log.d(\"실시간 버튼\",\"시작버튼 눌림 ${realTimeOnOffBtn.isChecked}\")\r\n            realTimeBtnOnClick()\r\n        }\r\n        binding.tourStart.setOnClickListener{\r\n            changeTourBtn()\r\n        }\r\n        binding.questPlus.setOnClickListener {\r\n            if (binding.plusExchange.visibility == View.GONE) {\r\n                binding.plusExchange.visibility = View.VISIBLE\r\n                binding.plusExchange.animate().scaleX(1f).scaleY(1f).alpha(1f).setDuration(300).start()\r\n            } else if (binding.plusExchange.visibility == View.VISIBLE) {\r\n                binding.plusExchange.animate().scaleX(0f).scaleY(0f).alpha(0f).setDuration(300).withEndAction {\r\n                    binding.plusExchange.visibility = View.GONE\r\n                }.start()\r\n            }\r\n\r\n            if (binding.plusRecruit.visibility == View.GONE) {\r\n                binding.plusRecruit.visibility = View.VISIBLE\r\n                binding.plusRecruit.animate().scaleX(1f).scaleY(1f).alpha(1f).setDuration(300).start()\r\n            } else if (binding.plusRecruit.visibility == View.VISIBLE) {\r\n                binding.plusRecruit.animate().scaleX(0f).scaleY(0f).alpha(0f).setDuration(300).withEndAction {\r\n                    binding.plusRecruit.visibility = View.GONE\r\n                }.start()\r\n            }\r\n\r\n            if (binding.plusShare.visibility == View.GONE) {\r\n                binding.plusShare.visibility = View.VISIBLE\r\n                binding.plusShare.animate().scaleX(1f).scaleY(1f).alpha(1f).setDuration(300).start()\r\n            } else if (binding.plusShare.visibility == View.VISIBLE) {\r\n                binding.plusShare.animate().scaleX(0f).scaleY(0f).alpha(0f).setDuration(300).withEndAction {\r\n                    binding.plusShare.visibility = View.GONE\r\n                }.start()\r\n            }\r\n        }\r\n        binding.plusExchange.setOnClickListener {\r\n            findNavController().navigate(R.id.action_mapFragment_to_exchangePostDialogFragment)\r\n        }\r\n        binding.plusShare.setOnClickListener {\r\n            findNavController().navigate(R.id.action_mapFragment_to_sharePostDialogFragment)\r\n        }\r\n        binding.plusRecruit.setOnClickListener {\r\n            findNavController().navigate(R.id.action_mapFragment_to_recruitPostDialogFragment)\r\n        }\r\n\r\n        /** LiveData Observe **/\r\n        FCMData.isAccept.observe(viewLifecycleOwner){\r\n            if(FCMData.isAccept.value != null && FCMData.isAccept.value!!){\r\n                findNavController().navigate(R.id.action_mapFragment_to_exchangeAcceptDialogFragment)\r\n                FCMData.isAccept.postValue(false)\r\n            }\r\n        }\r\n        mapViewModel.bottomSheetState.observe(viewLifecycleOwner) { state ->\r\n            when(state){\r\n                0 -> {\r\n                    sheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED\r\n                }\r\n                1 -> {\r\n                    sheetBehavior.state = BottomSheetBehavior.STATE_HALF_EXPANDED\r\n                }\r\n                2 -> {\r\n                    sheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED\r\n                }\r\n            }\r\n        }\r\n        mapViewModel.isQuestAlert.observe(viewLifecycleOwner) { questAlert ->\r\n            if(mainViewModel.isRealTimeOn) {\r\n                SnackBarFactory.show(this, binding, questAlert.questType)\r\n            }\r\n        }\r\n\r\n        // TODO. 아래 코드 onMapReady로 이동\r\n//        eventListViewModel.listToday.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized){\r\n//                todayClustering?.clearItems()\r\n//                todayClustering?.addItems(updatedMarkerList.map { it -> NaverItem(it.latitude, it.longitude, it, EventKind.TODAY) })\r\n//                Log.d(\"이벤트 리스트 변경\",\"오늘\")\r\n//            }\r\n//        }\r\n//        eventListViewModel.listUpcoming.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized) {\r\n//                upcomingClustering?.clearItems()\r\n//                upcomingClustering?.addItems(updatedMarkerList.map { it ->\r\n//                    NaverItem(\r\n//                        it.latitude,\r\n//                        it.longitude,\r\n//                        it,\r\n//                        EventKind.LATER\r\n//                    )\r\n//                })\r\n//                Log.d(\"이벤트 리스트 변경\", \"미래\")\r\n//            }\r\n//        }\r\n//        eventListViewModel.listPast.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized) {\r\n//                pastClustering?.clearItems()\r\n//                pastClustering?.addItems(updatedMarkerList.map { it ->\r\n//                    NaverItem(\r\n//                        it.latitude,\r\n//                        it.longitude,\r\n//                        it,\r\n//                        EventKind.PAST\r\n//                    )\r\n//                })\r\n//                Log.d(\"이벤트 리스트 변경\", \"과거\")\r\n//            }\r\n//        }\r\n//        eventListViewModel.likeListToday.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized) {\r\n//                todayClustering?.clearItems()\r\n//                todayClustering?.addItems(updatedMarkerList.map { it ->\r\n//                    NaverItem(\r\n//                        it.latitude,\r\n//                        it.longitude,\r\n//                        it,\r\n//                        EventKind.TODAY\r\n//                    )\r\n//                })\r\n//                Log.d(\"이벤트 리스트 변경\", \"오늘\")\r\n//            }\r\n//        }\r\n//        eventListViewModel.likeListUpcoming.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized) {\r\n//                upcomingClustering?.clearItems()\r\n//                upcomingClustering?.addItems(updatedMarkerList.map { it ->\r\n//                    NaverItem(\r\n//                        it.latitude,\r\n//                        it.longitude,\r\n//                        it,\r\n//                        EventKind.LATER\r\n//                    )\r\n//                })\r\n//                Log.d(\"이벤트 리스트 변경\", \"미래\")\r\n//            }\r\n//        }\r\n//        eventListViewModel.likeListPast.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n//            if(::naverMap.isInitialized) {\r\n//                pastClustering?.clearItems()\r\n//                pastClustering?.addItems(updatedMarkerList.map { it ->\r\n//                    NaverItem(\r\n//                        it.latitude,\r\n//                        it.longitude,\r\n//                        it,\r\n//                        EventKind.PAST\r\n//                    )\r\n//                })\r\n//                Log.d(\"이벤트 리스트 변경\", \"과거\")\r\n//            }\r\n//        }\r\n//        historyViewModel.route.observe(viewLifecycleOwner) { list ->\r\n//            if(::naverMap.isInitialized) {\r\n//                if (pathLine != null) pathLine!!.map = null\r\n//                setPathLine(list)\r\n//            }\r\n//        }\r\n//        historyViewModel.historyEventList.observe(viewLifecycleOwner) {\r\n//            if(::naverMap.isInitialized) {\r\n//                historyViewModel.setMarkerList()\r\n//            }\r\n//        }\r\n//        historyViewModel.markerList.observe(viewLifecycleOwner) { list ->\r\n//            if(::naverMap.isInitialized) {\r\n//                setHistoryMarker(list)\r\n//            }\r\n//        }\r\n    }\r\n\r\n    /** Init Functions **/\r\n    private fun initViewPager() {\r\n        mapPagerAdapter = MapPagerAdapter(this)\r\n        componentBottomSheetBinding.viewPager.adapter = mapPagerAdapter\r\n        componentBottomSheetBinding.viewPager.isUserInputEnabled = false\r\n\r\n        setHalfExpandedPadding()\r\n\r\n        componentBottomSheetBinding.viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {\r\n            override fun onPageSelected(position: Int) {\r\n                if (position != 5 && position != 2) {\r\n                    isHistoryEvent = false\r\n                }\r\n\r\n                if (position != 5 && !isHistoryEvent) {\r\n                    if (pathLine != null) {\r\n                        pathLine!!.map = null\r\n                        pathLine = null\r\n\r\n                        if (favoriteSettingViewModel.selectedCelebrity.value != null){\r\n                            CoroutineScope(Dispatchers.IO).launch{\r\n                                eventListViewModel.getEventList(\r\n                                    favoriteSettingViewModel.selectedCelebrity.value!!.id,\r\n                                    mapViewModel.pickedDate.value!!.first.toKotlinLocalDate(),\r\n                                    mapViewModel.pickedDate.value!!.second.toKotlinLocalDate())\r\n                            }\r\n                        }\r\n\r\n                        if (historyViewModel.markerList.value != null) {\r\n                            historyViewModel.markerList.value!!.forEach {\r\n                                it.map = null\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n    private fun initChildFragment() {\r\n        childFragmentManager.beginTransaction()\r\n            .add(R.id.fragment_top_appbar, TopAppbarFragment())\r\n            .setReorderingAllowed(true)\r\n            .addToBackStack(null)\r\n            .commit()\r\n    }\r\n    private fun setBottomSheet() {\r\n        val statusDp = getStatusBarHeightToDp(requireContext())\r\n\r\n        sheetBehavior = BottomSheetBehavior.from(componentBottomSheetBinding.bottomSheet)\r\n\r\n        sheetBehavior.expandedOffset = dpToPx(statusDp + 5, requireContext())\r\n\r\n        // TODO. BottomSheetBehavior state에 따른 이벤트 추후 추가\r\n        sheetBehavior.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() {\r\n            override fun onStateChanged(bottomSheet: View, newState: Int) {\r\n                when (newState) {\r\n                    BottomSheetBehavior.STATE_HIDDEN -> {\r\n                    }\r\n\r\n                    BottomSheetBehavior.STATE_HALF_EXPANDED -> {\r\n                        if (halfOffset != sheetBehavior.calculateSlideOffset()) halfOffset =\r\n                            sheetBehavior.calculateSlideOffset()\r\n\r\n                        setHalfExpandedPadding()\r\n                        prevOffset = halfOffset\r\n                    }\r\n\r\n                    BottomSheetBehavior.STATE_EXPANDED -> {\r\n                        prevOffset = 1.0f\r\n                    }\r\n\r\n                    BottomSheetBehavior.STATE_COLLAPSED -> {\r\n                        prevOffset = 0.0f\r\n                    }\r\n\r\n                    BottomSheetBehavior.STATE_DRAGGING -> {\r\n                    }\r\n\r\n                    BottomSheetBehavior.STATE_SETTLING -> {\r\n                    }\r\n                }\r\n            }\r\n\r\n            override fun onSlide(bottomSheet: View, slideOffset: Float) {\r\n                if (prevOffset < slideOffset && slideOffset > halfOffset) setExpandedPadding()\r\n            }\r\n        })\r\n    }\r\n    private fun setHalfExpandedPadding() {\r\n        binding.bsFragment.bottomSheet.setPadding(\r\n            0,\r\n            0,\r\n            0,\r\n            dpToPx(90, requireContext()) + heightPx / 2\r\n        )\r\n    }\r\n    private fun setExpandedPadding() {\r\n        binding.bsFragment.bottomSheet.setPadding(0, 0, 0, dpToPx(105, requireContext()))\r\n    }\r\n    @SuppressLint(\"ResourceType\")\r\n    private fun setRealTimeContainer(){\r\n        val statusBarDp = getStatusBarHeightToDp(requireContext())\r\n        val layoutParamsRealTimeContainer = binding.realTimeContainer.layoutParams as FrameLayout.LayoutParams\r\n        layoutParamsRealTimeContainer.topMargin = dpToPx(90 + statusBarDp, requireContext())\r\n        layoutParamsRealTimeContainer.rightMargin = dpToPx(10, requireContext())\r\n\r\n        val squareCircle = ContextCompat.getDrawable(requireContext(),R.drawable.shape_square_circle) as GradientDrawable\r\n        squareCircle.setColor(ContextCompat.getColor(requireContext(),R.color.white))\r\n        binding.realTimeTxt.background = squareCircle\r\n\r\n        val trackStates = arrayOf(\r\n            intArrayOf(android.R.attr.state_checked),\r\n            intArrayOf(-android.R.attr.state_checked)\r\n        )\r\n        val thumbStates = arrayOf(\r\n            intArrayOf(android.R.attr.state_checked),\r\n            intArrayOf(-android.R.attr.state_checked)\r\n        )\r\n\r\n        val trackColors = intArrayOf(\r\n            getColor(requireContext(), Theme.theme.main200),\r\n            getColor(requireContext(), R.color.white)\r\n\r\n        )\r\n        val thumbColors = intArrayOf(\r\n            getColor(requireContext(), Theme.theme.main500),\r\n            getColor(requireContext(), R.color.gray_text)\r\n        )\r\n\r\n        val trackColorStateList = ColorStateList(trackStates, trackColors)\r\n        val thumbColorStateList = ColorStateList(thumbStates, thumbColors)\r\n\r\n        binding.realTimeBtn.trackTintList = trackColorStateList\r\n        binding.realTimeBtn.thumbTintList = thumbColorStateList\r\n    }\r\n    private fun initQuestAlert(){\r\n        binding.mapQuestAlertContainer.visibility = View.GONE\r\n    }\r\n\r\n    /** Theme Settings **/\r\n    private fun setTourBtnTheme() {\r\n        tourStartCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        tourStartCircle.setColor(ContextCompat.getColor(requireContext(), R.color.green))\r\n        tourStartCircle.setStroke(0,0)\r\n        binding.tourStart.background= tourStartCircle\r\n\r\n        tourEndCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        tourEndCircle.setColor(ContextCompat.getColor(requireContext(), R.color.red))\r\n        tourEndCircle.setStroke(0,0)\r\n\r\n        val plusCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        plusCircle.setColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        plusCircle.setStroke(0,0)\r\n        binding.questPlus.background = plusCircle\r\n\r\n        val exchangeCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        exchangeCircle.setColor(ContextCompat.getColor(requireContext(), R.color.yellow))\r\n        exchangeCircle.setStroke(0,0)\r\n        binding.plusExchange.background = exchangeCircle\r\n        binding.plusExchange.setColorFilter(getColor(requireContext(), R.color.white))\r\n\r\n        val shareCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        shareCircle.setColor(ContextCompat.getColor(requireContext(), R.color.red))\r\n        shareCircle.setStroke(0,0)\r\n        binding.plusShare.background = shareCircle\r\n        binding.plusShare.setColorFilter(getColor(requireContext(), R.color.white))\r\n\r\n        val recruitCircle = ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        recruitCircle.setColor(ContextCompat.getColor(requireContext(), R.color.green))\r\n        recruitCircle.setStroke(0,0)\r\n        binding.plusRecruit.background = recruitCircle\r\n        binding.plusRecruit.setColorFilter(getColor(requireContext(), R.color.white))\r\n    }\r\n\r\n    /** Button Click & Callback Functions **/\r\n    private fun realTimeBtnOnClick(){\r\n        if(realTimeOnOffBtn.isChecked){\r\n            mainViewModel.isRealTimeOn = true\r\n            binding.mapPeoplecntContainer.visibility = View.VISIBLE\r\n        }\r\n        else{\r\n            deleteAllMarkers()\r\n            mainViewModel.isRealTimeOn = false\r\n            binding.mapPeoplecntContainer.visibility = View.GONE\r\n        }\r\n    }\r\n\r\n    private fun deleteAllMarkers(){\r\n        activity?.runOnUiThread {\r\n            mapViewModel.peopleMarkerList.value?.let { peopleMarkers ->\r\n                for ((_, marker) in peopleMarkers) {\r\n                    marker?.let {\r\n                        it.map = null\r\n                    }\r\n                }\r\n            }\r\n            mapViewModel.peopleMarkerList.postValue(emptyMap())\r\n        }\r\n    }\r\n\r\n    private fun initPeopleMarkerImage(): OverlayImage {\r\n        val sizeInPixels = dpToPx(50, requireContext())\r\n\r\n        val imageView = ImageView(requireContext()).apply {\r\n            layoutParams = ViewGroup.LayoutParams(sizeInPixels, sizeInPixels)\r\n            setImageResource(R.drawable.common_duck)\r\n        }\r\n        val bitmap = Bitmap.createBitmap(sizeInPixels, sizeInPixels, Bitmap.Config.ARGB_8888)\r\n        val canvas = Canvas(bitmap)\r\n        imageView.layout(0, 0, sizeInPixels, sizeInPixels)\r\n        imageView.draw(canvas)\r\n\r\n        return OverlayImage.fromBitmap(bitmap)\r\n    }\r\n    private fun changeTourBtn() {\r\n        if (binding.tourStart.text == \"투어\\n종료\") {\r\n            binding.tourStart.background = tourStartCircle\r\n            binding.tourStart.text = \"투어\\n시작\"\r\n            mapViewModel.isTourStart = false\r\n            if (timer != null) {\r\n                timer!!.cancel()\r\n                timer = null\r\n            }\r\n            val toast = Toast.makeText(requireContext(), \"투어가 종료되었습니다.\", Toast.LENGTH_SHORT)\r\n            toast.show()\r\n            // 마지막 종료 지점 좌표 넣기\r\n            if (ContextCompat.checkSelfPermission(\r\n                    requireContext(),\r\n                    Manifest.permission.ACCESS_FINE_LOCATION\r\n                ) == PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(\r\n                    requireContext(),\r\n                    Manifest.permission.ACCESS_COARSE_LOCATION\r\n                ) == PackageManager.PERMISSION_GRANTED) {\r\n\r\n                // 권한이 있을 경우, 마지막 위치 정보 가져오기\r\n                fusedLocationClient.lastLocation\r\n                    .addOnSuccessListener { location: Location? ->\r\n                        if(location != null){\r\n                            mapViewModel.tourList.add(Position(location.latitude, location.longitude))\r\n                        }\r\n                    }\r\n            }\r\n            // 실시간 위치 공유에서 종료 알림\r\n            stompManager.sendTourEnd( favoriteSettingViewModel.selectedCelebrity.value?.id ?: 1, mainViewModel.guid!!)\r\n            // 투어 기록 전송\r\n            CoroutineScope(Dispatchers.IO).launch {\r\n                Log.d(\"투어 기록\", mapViewModel.tourList.toString())\r\n                historyViewModel.sendHistory(historyViewModel.historyId.value!!, mapViewModel.tourList)\r\n                historyViewModel.getHistoryList(favoriteSettingViewModel.selectedCelebrity.value!!.id)\r\n                mapViewModel.initTourList()\r\n            }\r\n        } else if (binding.tourStart.text == \"투어\\n시작\") {\r\n            binding.tourStart.background = tourEndCircle\r\n            binding.tourStart.text = \"투어\\n종료\"\r\n            mapViewModel.isTourStart = true\r\n            sendPosition()\r\n            var toast = Toast.makeText(requireContext(), \"투어가 시작되었습니다.\", Toast.LENGTH_SHORT)\r\n            toast.show()\r\n            toast = Toast.makeText(requireContext(), \"투어가 진행되는 동안 상대방에게 위치가 공유됩니다.\", Toast.LENGTH_SHORT)\r\n            toast.show()\r\n            // 기록된 투어 post 요청\r\n            CoroutineScope(Dispatchers.IO).launch {\r\n                historyViewModel.createHistory(favoriteSettingViewModel.selectedCelebrity.value!!.id)\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun addBackPressedCallback() {\r\n        // OnBackPressedCallback (익명 클래스) 객체 생성\r\n        backPressedCallback = object : OnBackPressedCallback(true) {\r\n            var backWait: Long = 0\r\n\r\n            // 뒤로가기 했을 때 실행되는 기능\r\n            override fun handleOnBackPressed() {\r\n                when {\r\n                    componentBottomSheetBinding.viewPager.currentItem == 5 -> {\r\n                        changeViewPagerPage(4)\r\n                    }\r\n                    componentBottomSheetBinding.viewPager.currentItem == 2 -> {\r\n                        if (isHistoryEvent) {\r\n                            changeViewPagerPage(5)\r\n                            mapViewModel.setBottomSheet(1)\r\n                            isHistoryEvent = false\r\n                        } else {\r\n                            changeViewPagerPage(1)\r\n                        }\r\n                    }\r\n                    sheetBehavior.state == BottomSheetBehavior.STATE_EXPANDED -> {\r\n                        sheetBehavior.state = BottomSheetBehavior.STATE_HALF_EXPANDED\r\n                    }\r\n                    sheetBehavior.state == BottomSheetBehavior.STATE_HALF_EXPANDED -> {\r\n                        sheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED\r\n                    }\r\n                    else -> {\r\n                        if (System.currentTimeMillis() - backWait >= 2000) {\r\n                            backWait = System.currentTimeMillis()\r\n                            Toast.makeText(\r\n                                context, \"뒤로가기 버튼을 한번 더 누르면 이전 페이지로 이동합니다\",\r\n                                Toast.LENGTH_SHORT\r\n                            ).show()\r\n                        } else {\r\n                            findNavController().navigate(R.id.mainFragment)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 액티비티의 BackPressedDispatcher에 여기서 만든 callback 객체를 등록\r\n        requireActivity().onBackPressedDispatcher.addCallback(\r\n            viewLifecycleOwner,\r\n            backPressedCallback\r\n        )\r\n    }\r\n    private fun setPermissionListener() {\r\n        val permissionListener = object : PermissionListener {\r\n            override fun onPermissionGranted() {\r\n                Log.d(\"로그\", \"MainFragment - onPermissionGranted() 호출됨\")\r\n            }\r\n\r\n            override fun onPermissionDenied(deniedPermissions: MutableList<String>?) {\r\n                Toast.makeText(\r\n                    requireContext(),\r\n                    \"권한 거부\\n${deniedPermissions.toString()}\",\r\n                    Toast.LENGTH_SHORT\r\n                ).show()\r\n            }\r\n        }\r\n        requestPermission(permissionListener)\r\n    }\r\n\r\n\r\n    /**  Organization in Progress **/\r\n    private fun toast(message: String) {\r\n        Toast.makeText(requireContext(), message, Toast.LENGTH_SHORT)\r\n            .show()\r\n    }\r\n\r\n    fun changeViewPagerPage(pageIdx: Int, smoothScroll: Boolean = true) {\r\n        componentBottomSheetBinding.viewPager.setCurrentItem(pageIdx, smoothScroll)\r\n    }\r\n    fun getMarkerSize(zoom: Double) {\r\n        val baseZoomLevel = 17.0\r\n        val baseSize = 30\r\n\r\n        // 줌 레벨 변화에 따른 크기 조정\r\n        val sizeChange = (zoom - baseZoomLevel)*7\r\n        var size = baseSize + sizeChange\r\n        size = size.coerceAtMost(50.0).coerceAtLeast(1.0)\r\n        mapViewModel.markerSize = dpToPx(size.toInt(), requireContext())\r\n    }\r\n\r\n    override fun onMapReady(naverMap: NaverMap) {\r\n        val statusBarDp = getStatusBarHeightToDp(requireContext())\r\n\r\n        this.naverMap = naverMap\r\n        naverMap.locationSource = locationSource\r\n        naverMap.locationTrackingMode = LocationTrackingMode.Follow\r\n        mapViewModel.naverMap = naverMap\r\n\r\n        // 현재 위치 버튼 표시\r\n        naverMap.uiSettings.isLocationButtonEnabled = true\r\n\r\n        naverMap.setLayerGroupEnabled(NaverMap.LAYER_GROUP_TRANSIT, true)\r\n        naverMap.isIndoorEnabled = true\r\n\r\n        val uiSettings = naverMap.uiSettings\r\n\r\n        uiSettings.logoGravity = Gravity.TOP\r\n        uiSettings.setLogoMargin(\r\n            dpToPx(10, requireContext()),\r\n            dpToPx(90 + statusBarDp, requireContext()),\r\n            0,\r\n            0\r\n        )\r\n\r\n        uiSettings.isZoomControlEnabled = false\r\n        uiSettings.isCompassEnabled = false\r\n\r\n        naverMap.addOnCameraChangeListener{ reason, animated ->\r\n            val zoom = naverMap.cameraPosition.zoom\r\n            getMarkerSize(zoom)\r\n            mapViewModel.updateMarkerSize()\r\n        }\r\n\r\n        if (ActivityCompat.checkSelfPermission(\r\n                requireContext(),\r\n                Manifest.permission.ACCESS_FINE_LOCATION\r\n            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(\r\n                requireContext(),\r\n                Manifest.permission.ACCESS_COARSE_LOCATION\r\n            ) != PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            return\r\n        }\r\n\r\n        var currentLocation: Location?\r\n\r\n\r\n        fusedLocationClient.lastLocation\r\n            .addOnSuccessListener { location: Location? ->\r\n                if (location != null) {\r\n                    currentLocation = location\r\n                    // 현재 위치 아이콘 표시\r\n                    naverMap.locationOverlay.run {\r\n                        isVisible = true\r\n                        position = LatLng(currentLocation!!.latitude, currentLocation!!.longitude)\r\n                    }\r\n\r\n                    // 지도 중심 카메라 이동\r\n                    naverMap.moveCamera(\r\n                        CameraUpdate.scrollTo(\r\n                            LatLng(currentLocation!!.latitude, currentLocation!!.longitude)\r\n                        )\r\n                    )\r\n                }\r\n\r\n                initClusterTest()\r\n                getEventList()\r\n            }\r\n\r\n        eventListViewModel.listToday.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized){\r\n                todayClustering?.clearItems()\r\n                todayClustering?.addItems(updatedMarkerList.map { it -> NaverItem(it.latitude, it.longitude, it, EventKind.TODAY) })\r\n                Log.d(\"이벤트 리스트 변경\",\"오늘\")\r\n            }\r\n        }\r\n        eventListViewModel.listUpcoming.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized) {\r\n                upcomingClustering?.clearItems()\r\n                upcomingClustering?.addItems(updatedMarkerList.map { it ->\r\n                    NaverItem(\r\n                        it.latitude,\r\n                        it.longitude,\r\n                        it,\r\n                        EventKind.LATER\r\n                    )\r\n                })\r\n                Log.d(\"이벤트 리스트 변경\", \"미래\")\r\n            }\r\n        }\r\n        eventListViewModel.listPast.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized) {\r\n                pastClustering?.clearItems()\r\n                pastClustering?.addItems(updatedMarkerList.map { it ->\r\n                    NaverItem(\r\n                        it.latitude,\r\n                        it.longitude,\r\n                        it,\r\n                        EventKind.PAST\r\n                    )\r\n                })\r\n                Log.d(\"이벤트 리스트 변경\", \"과거\")\r\n            }\r\n        }\r\n        eventListViewModel.likeListToday.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized) {\r\n                todayClustering?.clearItems()\r\n                todayClustering?.addItems(updatedMarkerList.map { it ->\r\n                    NaverItem(\r\n                        it.latitude,\r\n                        it.longitude,\r\n                        it,\r\n                        EventKind.TODAY\r\n                    )\r\n                })\r\n                Log.d(\"이벤트 리스트 변경\", \"오늘\")\r\n            }\r\n        }\r\n        eventListViewModel.likeListUpcoming.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized) {\r\n                upcomingClustering?.clearItems()\r\n                upcomingClustering?.addItems(updatedMarkerList.map { it ->\r\n                    NaverItem(\r\n                        it.latitude,\r\n                        it.longitude,\r\n                        it,\r\n                        EventKind.LATER\r\n                    )\r\n                })\r\n                Log.d(\"이벤트 리스트 변경\", \"미래\")\r\n            }\r\n        }\r\n        eventListViewModel.likeListPast.observe(viewLifecycleOwner) { updatedMarkerList ->\r\n            if(::naverMap.isInitialized) {\r\n                pastClustering?.clearItems()\r\n                pastClustering?.addItems(updatedMarkerList.map { it ->\r\n                    NaverItem(\r\n                        it.latitude,\r\n                        it.longitude,\r\n                        it,\r\n                        EventKind.PAST\r\n                    )\r\n                })\r\n                Log.d(\"이벤트 리스트 변경\", \"과거\")\r\n            }\r\n        }\r\n        historyViewModel.route.observe(viewLifecycleOwner) { list ->\r\n            if(::naverMap.isInitialized) {\r\n                if (pathLine != null) pathLine!!.map = null\r\n                setPathLine(list)\r\n            }\r\n        }\r\n        historyViewModel.historyEventList.observe(viewLifecycleOwner) {\r\n            if(::naverMap.isInitialized) {\r\n                historyViewModel.setMarkerList()\r\n            }\r\n        }\r\n        historyViewModel.markerList.observe(viewLifecycleOwner) { list ->\r\n            if(::naverMap.isInitialized) {\r\n                setHistoryMarker(list)\r\n            }\r\n        }\r\n    }\r\n    // 권한 설정 알림\r\n    private fun requestPermission(permissionListener: PermissionListener) {\r\n        TedPermission.create()\r\n            .setPermissionListener(permissionListener)\r\n            .setRationaleMessage(\"위치 정보 제공이 필요한 서비스입니다.\")\r\n            .setDeniedMessage(\"[설정] -> [권한]에서 권한 변경이 가능합니다.\")\r\n            .setDeniedCloseButtonText(\"닫기\")\r\n            .setGotoSettingButtonText(\"설정\")\r\n            .setPermissions(\r\n                Manifest.permission.ACCESS_COARSE_LOCATION,\r\n                Manifest.permission.ACCESS_FINE_LOCATION,\r\n            )\r\n            .check()\r\n    }\r\n\r\n    // 네이버 지도 초기화\r\n    private fun initMapView() {\r\n        val fm = childFragmentManager\r\n        val mapFragment = fm.findFragmentById(R.id.map) as MapFragment?\r\n            ?: MapFragment.newInstance().also {\r\n                fm.beginTransaction().add(R.id.map, it).commit()\r\n            }\r\n\r\n        mapFragment.getMapAsync(this)\r\n        locationSource = FusedLocationSource(this, LOCATION_PERMISSION_REQUEST_CODE)\r\n\r\n        mapFragment.getMapAsync {\r\n            val statusBarDp = getStatusBarHeightToDp(requireContext())\r\n\r\n            val locationBtn = binding.locationBtn\r\n            val layoutParams = locationBtn.layoutParams as FrameLayout.LayoutParams\r\n\r\n            layoutParams.marginStart = dpToPx(8, requireContext())\r\n            layoutParams.topMargin = dpToPx(115 + statusBarDp, requireContext())\r\n\r\n            locationBtn.layoutParams = layoutParams\r\n            locationBtn.map = naverMap\r\n        }\r\n    }\r\n\r\n    // 이벤트 리스트 가져옴\r\n    private fun getEventList() {\r\n        CoroutineScope(Dispatchers.IO).launch {\r\n            val celebrityId = favoriteSettingViewModel.selectedCelebrity.value?.id ?: return@launch\r\n            val (startDate, endDate) = mapViewModel.pickedDate.value ?: return@launch\r\n            eventListViewModel.getEventList(celebrityId, startDate.toKotlinLocalDate(), endDate.toKotlinLocalDate())\r\n        }\r\n    }\r\n\r\n    // 클러스터 관리 메소드\r\n    private fun initCluster() {\r\n        // 마커, 클러스터 주변 원 리스트\r\n        val circleOverlayList = mutableMapOf<LatLng, CircleOverlay>()\r\n\r\n//        setPathLine(markerList)\r\n\r\n        clustering = TedNaverClustering.with<NaverItem>(requireContext(), naverMap)\r\n//            .items(markerList)\r\n            .customMarker { clusterItem ->\r\n                Marker(clusterItem.position).apply {\r\n                    icon = MarkerIcons.BLACK\r\n                    iconTintColor = getColor(requireContext(), Theme.theme.main500)\r\n                    width = dpToPx(22, requireContext())\r\n                    height = dpToPx(30, requireContext())\r\n                }\r\n            }\r\n            .customCluster {\r\n                val circleDrawable = ContextCompat.getDrawable(\r\n                    requireContext(),\r\n                    R.drawable.shape_circle\r\n                ) as GradientDrawable\r\n                circleDrawable.setColor(getColor(requireContext(), Theme.theme.main500))\r\n                circleDrawable.setStroke(2, getColor(requireContext(), Theme.theme.main500))\r\n\r\n                TextView(requireContext()).apply {\r\n                    background = circleDrawable\r\n                    setTextColor(Color.WHITE)\r\n                    text = \"${it.size}\"\r\n                    width = dpToPx(40, requireContext())\r\n                    height = dpToPx(40, requireContext())\r\n                    gravity = Gravity.CENTER\r\n                }\r\n            }\r\n            // 마커가 추가되었을 때 이벤트\r\n            .markerAddedListener { clusterItem, _ ->\r\n                if (circleOverlayList[clusterItem.position] == null) {\r\n                    circleOverlayList[clusterItem.position] = CircleOverlay().builder(\r\n                        clusterItem.position,\r\n                        100.0,\r\n                        requireContext(),\r\n                        naverMap\r\n                    )\r\n                } else {\r\n                    circleOverlayList[clusterItem.position]!!.radius = 150.0\r\n                    circleOverlayList[clusterItem.position]!!.map = naverMap\r\n                }\r\n            }\r\n            // 클러스터 정보가 변경되었을 때 이벤트\r\n            .clusterAddedListener { cluster, tedNaverMarker ->\r\n                val radius = cluster.size * 100.0\r\n\r\n                cluster.items.forEach { naverItem ->\r\n                    if (circleOverlayList[naverItem.position] != null) {\r\n                        circleOverlayList[naverItem.position]!!.map = null\r\n                    }\r\n                }\r\n\r\n                val closet = cluster.items.closet(tedNaverMarker.marker.position)\r\n\r\n                if (circleOverlayList[closet] == null) {\r\n                    circleOverlayList[closet] = CircleOverlay().builder(\r\n                        closet,\r\n                        radius,\r\n                        requireContext(),\r\n                        naverMap\r\n                    )\r\n                } else {\r\n                    circleOverlayList[closet]!!.radius = radius\r\n                    circleOverlayList[closet]!!.map = naverMap\r\n                }\r\n\r\n                readjustCluster()\r\n            }\r\n            // 클러스터를 클릭했을 때 이벤트\r\n            .clusterClickListener { cluster ->\r\n                val position = cluster.position\r\n\r\n                val cameraPosition = CameraPosition(\r\n                    LatLng(position.latitude, position.longitude),\r\n                    naverMap.cameraPosition.zoom + 2\r\n                )\r\n\r\n                naverMap.moveCamera(\r\n                    CameraUpdate\r\n                        .toCameraPosition(cameraPosition)\r\n                        .animate(CameraAnimation.Fly)\r\n                )\r\n            }\r\n            // 마커를 클릭했을 때 이벤트\r\n            .markerClickListener { naverItem ->\r\n                val position = naverItem.position\r\n\r\n                naverMap.moveCamera(\r\n                    CameraUpdate.scrollTo(LatLng(position.latitude, position.longitude))\r\n                )\r\n            }\r\n            .make()\r\n\r\n        clustering\r\n            ?.setAlgorithm(NonHierarchicalViewBasedAlgorithm(1000, 1000))\r\n    }\r\n\r\n    // 가장 가까운 마커의 위치를 반환하는 메소드\r\n    private fun Collection<NaverItem>.closet(pos: LatLng): LatLng {\r\n        var min = Double.MAX_VALUE\r\n        var result: LatLng = this.toList().first().position\r\n\r\n        this.forEach { naverItem ->\r\n            val latSquare =\r\n                (naverItem.position.latitude - pos.latitude) * (naverItem.position.latitude - pos.latitude)\r\n            val longSquare =\r\n                (naverItem.position.longitude - pos.longitude) * (naverItem.position.longitude - pos.longitude)\r\n            if (min > latSquare + longSquare) {\r\n                min = latSquare + longSquare\r\n                result = naverItem.position\r\n            }\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    // 카메라 위치를 미세 이동해서 클러스터 위치 재조정\r\n    private fun readjustCluster() {\r\n        val cPos = naverMap.cameraPosition.target\r\n\r\n        naverMap.moveCamera(\r\n            CameraUpdate.scrollTo(\r\n                LatLng(cPos.latitude + 0.00000001, cPos.longitude + 0.00000001)\r\n            )\r\n        )\r\n\r\n        naverMap.moveCamera(CameraUpdate.scrollTo(cPos))\r\n    }\r\n\r\n    // 이동 경로를 경로선으로 표시\r\n    private fun setPathLine(list: List<Position>) {\r\n        if(::naverMap.isInitialized){\r\n            pathLine = PathOverlay()\r\n            val pathLineList = mutableListOf<LatLng>()\r\n\r\n            list.forEach { (latitude, longitude) ->\r\n                pathLineList.add(LatLng(latitude, longitude))\r\n            }\r\n\r\n            if (list.isNotEmpty() && pathLine != null) {\r\n                pathLine!!.width = 30\r\n                pathLine!!.outlineWidth = 5\r\n                pathLine!!.coords = pathLineList\r\n                pathLine!!.map = naverMap\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private fun handleButtonClick(\r\n        showFab: LinearLayout,\r\n        hideList: List<LinearLayout>,\r\n    ) {\r\n        Log.d(\"검증\", \"buttonclick func\")\r\n        for (fab in hideList) {\r\n            fab.visibility = View.INVISIBLE\r\n        }\r\n        showFab.visibility = View.VISIBLE\r\n    }\r\n\r\n    private fun setUpPeopleNumber(){\r\n        val statusBarDp = getStatusBarHeightToDp(requireContext())\r\n        val mapPeoplecntContainerParams = binding.mapPeoplecntContainer.layoutParams as FrameLayout.LayoutParams\r\n        mapPeoplecntContainerParams.topMargin = dpToPx(110 + statusBarDp, requireContext())\r\n        val roundSquare = ContextCompat.getDrawable(requireContext(), R.drawable.shape_square_circle) as GradientDrawable\r\n        roundSquare.setColor(ContextCompat.getColor(requireContext(),R.color.white))\r\n        roundSquare.setStroke(0,0)\r\n        binding.mapPeoplecntContainer.background = roundSquare\r\n        binding.mapPeoplecntText.setTextColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        binding.mapPeoplecntContainer.visibility = View.GONE\r\n    }\r\n\r\n    private fun setUpBackgroundRoundCorner() {\r\n        // Bottom Appbar Background\r\n        val upperRoundCorner = ContextCompat.getDrawable(\r\n            requireContext(),\r\n            R.drawable.shape_upper_round_25\r\n        ) as GradientDrawable\r\n        upperRoundCorner.setColor(ContextCompat.getColor(requireContext(), Theme.theme.main100))\r\n        val background: ConstraintLayout = componentBottomAppbarBinding.navBackground\r\n        background.background = upperRoundCorner\r\n    }\r\n\r\n    private fun setUpBackgroundButtonIcon() {\r\n        // Normal Buttons : Icons (Main 500)\r\n        val icQuest: ImageView = componentBottomAppbarBinding.icQuest\r\n        val icList: ImageView = componentBottomAppbarBinding.icList\r\n        val icChat: ImageView = componentBottomAppbarBinding.icChat\r\n        val icMyrecord: ImageView = componentBottomAppbarBinding.icMyrecord\r\n        val icons: List<ImageView> = listOf(icQuest, icList, icChat, icMyrecord)\r\n        for (icon in icons) {\r\n            icon.setColorFilter(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        }\r\n    }\r\n\r\n    private fun setUpBottomText() {\r\n        val textQuest: TextView = componentBottomAppbarBinding.textQuest\r\n        val textList: TextView = componentBottomAppbarBinding.textList\r\n        val textChat: TextView = componentBottomAppbarBinding.textChat\r\n        val textMyRecord: TextView = componentBottomAppbarBinding.textMyrecord\r\n        val texts: List<TextView> = listOf(textQuest, textList, textChat, textMyRecord)\r\n        for (text in texts) {\r\n            text.setTextColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        }\r\n        textQuest.text = \"Quest\"\r\n        textList.text = \"List\"\r\n        textChat.text = \"Likes\"\r\n        textMyRecord.text = \"History\"\r\n    }\r\n\r\n    private fun setUpFloatingButton() {\r\n        // Floating Buttons : Buttons (Main 500)\r\n        val fabQuest: LinearLayout = componentBottomAppbarBinding.fabQuest\r\n        val fabList: LinearLayout = componentBottomAppbarBinding.fabList\r\n        val fabChat: LinearLayout = componentBottomAppbarBinding.fabChat\r\n        val fabMyrecord: LinearLayout = componentBottomAppbarBinding.fabMyrecord\r\n        val circle =\r\n            ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        circle.setColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        circle.setStroke(0, 0)\r\n\r\n        val fabs: List<LinearLayout> = listOf(fabQuest, fabList, fabChat, fabMyrecord)\r\n        for (fab in fabs) {\r\n            fab.background = circle;\r\n        }\r\n\r\n        componentBottomAppbarBinding.buttonQuest.setOnClickListener {\r\n            componentBottomSheetBinding.viewPager.setCurrentItem(0, false)\r\n            mapViewModel.setBottomSheet(1)\r\n            handleButtonClick(fabQuest, listOf(fabList, fabChat, fabMyrecord))\r\n        }\r\n        componentBottomAppbarBinding.buttonList.setOnClickListener {\r\n            componentBottomSheetBinding.viewPager.setCurrentItem(1, false)\r\n            mapViewModel.setBottomSheet(1)\r\n            handleButtonClick(fabList, listOf(fabQuest, fabChat, fabMyrecord))\r\n        }\r\n        componentBottomAppbarBinding.buttonChat.setOnClickListener {\r\n            componentBottomSheetBinding.viewPager.setCurrentItem(3, false)\r\n            mapViewModel.setBottomSheet(1)\r\n            handleButtonClick(fabChat, listOf(fabQuest, fabList, fabMyrecord))\r\n        }\r\n        componentBottomAppbarBinding.buttonMyrecord.setOnClickListener {\r\n            componentBottomSheetBinding.viewPager.setCurrentItem(4, false)\r\n            mapViewModel.setBottomSheet(1)\r\n            handleButtonClick(fabMyrecord, listOf(fabQuest, fabList, fabChat))\r\n        }\r\n    }\r\n\r\n    private fun bottomAppBarClick(kind: Int) {\r\n        // Floating Buttons : Buttons (Main 500)\r\n        val fabQuest: LinearLayout = componentBottomAppbarBinding.fabQuest\r\n        val fabList: LinearLayout = componentBottomAppbarBinding.fabList\r\n        val fabChat: LinearLayout = componentBottomAppbarBinding.fabChat\r\n        val fabMyrecord: LinearLayout = componentBottomAppbarBinding.fabMyrecord\r\n        val circle =\r\n            ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        circle.setColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        circle.setStroke(0, 0)\r\n\r\n        val fabs: List<LinearLayout> = listOf(fabQuest, fabList, fabChat, fabMyrecord)\r\n        for (fab in fabs) {\r\n            fab.background = circle;\r\n        }\r\n\r\n        when(kind){\r\n            0 -> {\r\n                componentBottomSheetBinding.viewPager.setCurrentItem(0, false)\r\n                mapViewModel.setBottomSheet(1)\r\n                handleButtonClick(fabQuest, listOf(fabList, fabChat, fabMyrecord))\r\n            }\r\n            1 -> {\r\n                componentBottomSheetBinding.viewPager.setCurrentItem(1, false)\r\n                mapViewModel.setBottomSheet(1)\r\n                handleButtonClick(fabList, listOf(fabQuest, fabChat, fabMyrecord))\r\n            }\r\n            2 -> {\r\n                componentBottomSheetBinding.viewPager.setCurrentItem(3, false)\r\n                mapViewModel.setBottomSheet(1)\r\n                handleButtonClick(fabChat, listOf(fabQuest, fabList, fabMyrecord))\r\n            }\r\n            3 -> {\r\n                componentBottomSheetBinding.viewPager.setCurrentItem(4, false)\r\n                mapViewModel.setBottomSheet(1)\r\n                handleButtonClick(fabMyrecord, listOf(fabQuest, fabList, fabChat))\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun changeBottomAppBarIcon(kind: Int) {\r\n        // Floating Buttons : Buttons (Main 500)\r\n        val fabQuest: LinearLayout = componentBottomAppbarBinding.fabQuest\r\n        val fabList: LinearLayout = componentBottomAppbarBinding.fabList\r\n        val fabChat: LinearLayout = componentBottomAppbarBinding.fabChat\r\n        val fabMyrecord: LinearLayout = componentBottomAppbarBinding.fabMyrecord\r\n        val circle =\r\n            ContextCompat.getDrawable(requireContext(), R.drawable.shape_circle) as GradientDrawable\r\n        circle.setColor(ContextCompat.getColor(requireContext(), Theme.theme.main500))\r\n        circle.setStroke(0, 0)\r\n\r\n        val fabs: List<LinearLayout> = listOf(fabQuest, fabList, fabChat, fabMyrecord)\r\n        for (fab in fabs) {\r\n            fab.background = circle;\r\n        }\r\n\r\n        when(kind){\r\n            0 -> {\r\n                handleButtonClick(fabQuest, listOf(fabList, fabChat, fabMyrecord))\r\n            }\r\n            1 -> {\r\n                handleButtonClick(fabList, listOf(fabQuest, fabChat, fabMyrecord))\r\n            }\r\n            2 -> {\r\n                handleButtonClick(fabChat, listOf(fabQuest, fabList, fabMyrecord))\r\n            }\r\n            3 -> {\r\n                handleButtonClick(fabMyrecord, listOf(fabQuest, fabList, fabChat))\r\n            }\r\n        }\r\n    }\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        _binding = null\r\n        _componentBottomAppbarBinding = null\r\n        _componentBottomAppbarBinding = null\r\n        backPressedCallback.remove()\r\n    }\r\n\r\n    companion object {\r\n        private const val LOCATION_PERMISSION_REQUEST_CODE = 1000\r\n    }\r\n\r\n\r\n\r\n    // 클러스터 생성 -----------------------------------------------------------------------------------------------\r\n    private fun initClusterTest() {\r\n        pastClustering = TedNaverClustering.with<NaverItem>(requireContext(), naverMap).apply {\r\n            setupCustomMarker(EventKind.PAST)\r\n            setupCustomCluster(EventKind.PAST)\r\n//            setupMarkerAddedListener(circleOverlayList)\r\n//            setupClusterAddedListener(circleOverlayList)\r\n            setupClusterClickListener()\r\n            setupMarkerClickListener()\r\n        }.make()\r\n        pastClustering?.setAlgorithm(NonHierarchicalViewBasedAlgorithm(1000, 1000))\r\n\r\n        todayClustering = TedNaverClustering.with<NaverItem>(requireContext(), naverMap).apply {\r\n            setupCustomMarker(EventKind.TODAY)\r\n            setupCustomCluster(EventKind.TODAY)\r\n//            setupMarkerAddedListener(circleOverlayList)\r\n//            setupClusterAddedListener(circleOverlayList)\r\n            setupClusterClickListener()\r\n            setupMarkerClickListener()\r\n        }.make()\r\n        todayClustering?.setAlgorithm(NonHierarchicalViewBasedAlgorithm(1000, 1000))\r\n\r\n        upcomingClustering = TedNaverClustering.with<NaverItem>(requireContext(), naverMap).apply {\r\n            setupCustomMarker(EventKind.LATER)\r\n            setupCustomCluster(EventKind.LATER)\r\n//            setupMarkerAddedListener(circleOverlayList)\r\n//            setupClusterAddedListener(circleOverlayList)\r\n            setupClusterClickListener()\r\n            setupMarkerClickListener()\r\n        }.make()\r\n        upcomingClustering?.setAlgorithm(NonHierarchicalViewBasedAlgorithm(1000, 1000))\r\n    }\r\n\r\n    private fun getClusterColor(kind: EventKind): Int{\r\n        return when(kind){\r\n            EventKind.PAST -> getColor(requireContext(), R.color.gray_text)\r\n            EventKind.TODAY -> getColor(requireContext(), Theme.theme.main500)\r\n            EventKind.LATER -> getColor(requireContext(), Theme.theme.main300)\r\n        }\r\n    }\r\n\r\n    private fun TedNaverClustering.Builder<NaverItem>.setupCustomMarker(kind: EventKind) = apply {\r\n        customMarker { clusterItem ->\r\n            Marker(clusterItem.position).apply {\r\n                icon = MarkerIcons.BLACK\r\n                iconTintColor = getClusterColor(kind)\r\n                width = dpToPx(22, requireContext())\r\n                height = dpToPx(30, requireContext())\r\n                // 이 `apply` 블록의 결과 (즉, Marker 객체 자체)가 반환됩니다.\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun TedNaverClustering.Builder<NaverItem>.setupCustomCluster(kind: EventKind) = apply {\r\n        customCluster {\r\n            val circleDrawable = ContextCompat.getDrawable(\r\n                requireContext(),\r\n                R.drawable.shape_circle\r\n            ) as GradientDrawable\r\n            circleDrawable.setColor(getClusterColor(kind))\r\n            circleDrawable.setStroke(2, getClusterColor(kind))\r\n\r\n            TextView(requireContext()).apply {\r\n                background = circleDrawable\r\n                setTextColor(Color.WHITE)\r\n                text = \"${it.size}\"\r\n                width = dpToPx(40, requireContext())\r\n                height = dpToPx(40, requireContext())\r\n                gravity = Gravity.CENTER\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun TedNaverClustering.Builder<NaverItem>.setupMarkerAddedListener(circleOverlayList: MutableMap<LatLng, CircleOverlay>) = apply {\r\n        markerAddedListener { clusterItem, _ ->\r\n            if (circleOverlayList[clusterItem.position] == null) {\r\n                circleOverlayList[clusterItem.position] = CircleOverlay().builder(\r\n                    clusterItem.position,\r\n                    100.0,\r\n                    requireContext(),\r\n                    naverMap\r\n                )\r\n            } else {\r\n                circleOverlayList[clusterItem.position]!!.radius = 150.0\r\n                circleOverlayList[clusterItem.position]!!.map = naverMap\r\n            }\r\n        }\r\n    }\r\n\r\n    fun TedNaverClustering.Builder<NaverItem>.setupClusterAddedListener(circleOverlayList: MutableMap<LatLng, CircleOverlay>) = apply {\r\n        clusterAddedListener { cluster, tedNaverMarker ->\r\n            val radius = cluster.size * 100.0\r\n\r\n            cluster.items.forEach { naverItem ->\r\n                if (circleOverlayList[naverItem.position] != null) {\r\n                    circleOverlayList[naverItem.position]!!.map = null\r\n                }\r\n            }\r\n\r\n            val closet = cluster.items.closet(tedNaverMarker.marker.position)\r\n\r\n            if (circleOverlayList[closet] == null) {\r\n                circleOverlayList[closet] = CircleOverlay().builder(\r\n                    closet,\r\n                    radius,\r\n                    requireContext(),\r\n                    naverMap\r\n                )\r\n            } else {\r\n                circleOverlayList[closet]!!.radius = radius\r\n                circleOverlayList[closet]!!.map = naverMap\r\n            }\r\n\r\n            readjustCluster()\r\n        }\r\n    }\r\n\r\n    fun TedNaverClustering.Builder<NaverItem>.setupClusterClickListener() = apply {\r\n        clusterClickListener { cluster ->\r\n            val position = cluster.position\r\n\r\n            val cameraPosition = CameraPosition(\r\n                LatLng(position.latitude, position.longitude),\r\n                naverMap.cameraPosition.zoom + 2\r\n            )\r\n\r\n            naverMap.moveCamera(\r\n                CameraUpdate\r\n                    .toCameraPosition(cameraPosition)\r\n                    .animate(CameraAnimation.Fly)\r\n            )\r\n        }\r\n    }\r\n\r\n    fun TedNaverClustering.Builder<NaverItem>.setupMarkerClickListener() = apply {\r\n        markerClickListener { naverItem ->\r\n            Log.d(\"이벤트 클릭\", naverItem.event.toString())\r\n            // 이벤트 화면으로 이동\r\n            eventListViewModel.setSelectedEvent(naverItem.event!!)\r\n            if (naverItem.eventType == EventKind.TODAY) {\r\n                bottomAppBarClick(0)\r\n            }\r\n            else{\r\n                changeBottomAppBarIcon(1)\r\n                eventListViewModel.isDetailOpen.value = true\r\n            }\r\n            val position = naverItem.position\r\n            val cameraPosition = CameraPosition(LatLng(position.latitude, position.longitude), 18.0)\r\n            naverMap.moveCamera(CameraUpdate.toCameraPosition(cameraPosition))\r\n        }\r\n    }\r\n    // ---------------------------------------------------------------------------------------------\r\n\r\n\r\n    private fun doWorkWithPeriodic() {\r\n        Log.d(\"로그\", \"doWorkWithPeriodic() 호출됨\")\r\n\r\n        // TODO. GPSWorker 클래스에서 위치 기록 저장 및 전송 로직 추가 필요\r\n        // [메모]\r\n        // GPSWorker 클래스에서 뷰모델의 데이터에 접근 하려면 어떻게 해야 하나요?\r\n        // 선택된 아이돌 id, 당일 열리는 이벤트 리스트(today event)가 필요할 것 같은데\r\n        // GPSWorker가 받은 좌표를 아니면 MapFragment에서 받을 수 았나?\r\n\r\n        workRequest = PeriodicWorkRequestBuilder<GPSWorker>(15, TimeUnit.MINUTES).build()\r\n\r\n        workManager = WorkManager.getInstance(requireContext())\r\n        workManager?.enqueueUniquePeriodicWork(\r\n            \"doWorkWithPeriodic\",\r\n            ExistingPeriodicWorkPolicy.UPDATE,\r\n            workRequest\r\n        )\r\n    }\r\n\r\n    private fun cancelWorkWithPeriodic() {\r\n        workManager?.cancelWorkById(workRequest.id)\r\n    }\r\n\r\n    @SuppressLint(\"MissingPermission\")\r\n    private fun sendPosition() {\r\n        timer = Timer()\r\n        timer?.scheduleAtFixedRate(object : TimerTask() {\r\n            val favorite = favoriteSettingViewModel.selectedCelebrity.value?.id\r\n            override fun run() {\r\n                if (TedPermissionUtil.isGranted(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                    fusedLocationClient.lastLocation\r\n                        .addOnSuccessListener { location: Location? ->\r\n                            Log.d(\"로그\", \"lastLocation : ${location?.latitude} ${location?.longitude}\")\r\n                            if(location!= null){\r\n                                // 좌표 리스트에 등록\r\n                                if(mapViewModel.addTourRecord(location.latitude, location.longitude)){\r\n                                    // 이벤트 리스트 확인, 가까운 리스트 갱신\r\n                                    if(!mapViewModel.isCloseDialogOpen){\r\n                                        mapViewModel.isCloseDialogOpen = true\r\n                                        figureCloseEvents(location.latitude, location.longitude)\r\n                                    }\r\n                                    // 웹소켓 전송 (추후 url, 전송 형식 백엔드에 맞춰 변경)\r\n                                    stompManager.sendLocation(\r\n                                        favoriteSettingViewModel.selectedCelebrity.value?.id ?: 1,\r\n                                        location.latitude,\r\n                                        location.longitude,\r\n                                        mainViewModel.guid!!\r\n                                    )\r\n                                }\r\n                                //TODO else문 삭제\r\n                                else{\r\n                                    stompManager.sendLocation(\r\n                                        favoriteSettingViewModel.selectedCelebrity.value?.id ?: 1,\r\n                                        location.latitude,\r\n                                        location.longitude,\r\n                                        mainViewModel.guid!!\r\n                                    )\r\n                                }\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n        }, 0 , 5 * 1000)\r\n    }\r\n\r\n    private fun figureCloseEvents(lat:Double, lng:Double) {\r\n        mapViewModel.eventList = mutableListOf()\r\n        eventListViewModel.listToday.value?.let { list ->\r\n            Log.d(\"오늘 이벤트\", list.toString())\r\n            for (event in list) {\r\n                if(!event.isVisited && CalcDistance.isDistanceOk(lat, lng, event.latitude, event.longitude)){\r\n                    mapViewModel.eventList.add(event)\r\n                }\r\n            }\r\n        }\r\n        eventListViewModel.closeEvents.value = mapViewModel.eventList\r\n        Log.d(\"가까운 이벤트 탐색 결과\", mapViewModel.eventList.toString())\r\n        if(!mapViewModel.eventList.isEmpty()){\r\n            findNavController().navigate(R.id.action_mapFragment_to_eventCloseDialog)\r\n        }\r\n    }\r\n\r\n    override fun onStart() {\r\n        super.onStart()\r\n        Log.d(\"로그\", \"MapFragment - onStart() 호출됨\")\r\n\r\n        realTimeBtnOnClick()\r\n\r\n        if (mapViewModel.isTourStart == true && timer == null) sendPosition()\r\n        if (workManager != null) cancelWorkWithPeriodic()\r\n    }\r\n\r\n    override fun onStop() {\r\n        super.onStop()\r\n        Log.d(\"로그\", \"MapFragment - onStop() 호출됨\")\r\n        if (mapViewModel.isTourStart == true) doWorkWithPeriodic()\r\n        if (timer != null) {\r\n            timer!!.cancel()\r\n            timer = null\r\n        }\r\n    }\r\n\r\n    private fun setHistoryMarker(list: List<Marker>) {\r\n        list.forEach { marker ->\r\n            marker.apply {\r\n                icon = MarkerIcons.BLACK\r\n                iconTintColor = getClusterColor(EventKind.TODAY)\r\n                width = dpToPx(22, requireContext())\r\n                height = dpToPx(30, requireContext())\r\n                map = naverMap\r\n            }\r\n\r\n            var eventId: Long? = null\r\n\r\n            historyViewModel.historyEventList.value?.forEach { historyTour ->\r\n                if (marker.position.latitude == historyTour.latitude && marker.position.longitude == historyTour.longitude) {\r\n                    eventId = historyTour.eventId\r\n                }\r\n            }\r\n\r\n            if (eventId != null) {\r\n                val listener = Overlay.OnClickListener { overlay ->\r\n                    isHistoryEvent = true\r\n                    CoroutineScope(Dispatchers.IO).launch {\r\n                        val deferred = async {\r\n                            eventListViewModel.getEventById(eventId!!)\r\n                        }\r\n\r\n                        val event = deferred.await()\r\n\r\n                        if (event != null) {\r\n                            launch(Dispatchers.Main) {\r\n                                eventListViewModel.setSelectedEvent(event)\r\n                                changeViewPagerPage(2)\r\n                                mapViewModel.setBottomSheet(2)\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    true\r\n                }\r\n\r\n                marker.onClickListener = listener\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/idle/togeduck/main_map/view/MapFragment.kt b/app/src/main/java/com/idle/togeduck/main_map/view/MapFragment.kt
--- a/app/src/main/java/com/idle/togeduck/main_map/view/MapFragment.kt	(revision fef057f5fc91674e99d142fb37e781e5ea4564a1)
+++ b/app/src/main/java/com/idle/togeduck/main_map/view/MapFragment.kt	(date 1707960681102)
@@ -34,10 +34,12 @@
 import androidx.work.PeriodicWorkRequest
 import androidx.work.PeriodicWorkRequestBuilder
 import androidx.work.WorkManager
+import androidx.work.workDataOf
 import com.google.android.gms.location.FusedLocationProviderClient
 import com.google.android.gms.location.LocationServices
 import com.google.android.material.bottomsheet.BottomSheetBehavior
 import com.google.android.material.materialswitch.MaterialSwitch
+import com.google.gson.GsonBuilder
 import com.gun0912.tedpermission.PermissionListener
 import com.gun0912.tedpermission.TedPermissionUtil
 import com.gun0912.tedpermission.normal.TedPermission
@@ -1436,7 +1438,18 @@
         // 선택된 아이돌 id, 당일 열리는 이벤트 리스트(today event)가 필요할 것 같은데
         // GPSWorker가 받은 좌표를 아니면 MapFragment에서 받을 수 았나?
 
-        workRequest = PeriodicWorkRequestBuilder<GPSWorker>(15, TimeUnit.MINUTES).build()
+
+        val gson = GsonBuilder().create()
+        val tourListJson = gson.toJson(mapViewModel.tourList)
+
+
+        workRequest = PeriodicWorkRequestBuilder<GPSWorker>(15, TimeUnit.MINUTES)
+            .setInputData(workDataOf(
+                "celebrityId" to ((favoriteSettingViewModel.selectedCelebrity.value?.id) ?: 1L),
+                "guid" to mainViewModel.guid!!,
+                "tourList" to tourListJson
+            ))
+            .build()
 
         workManager = WorkManager.getInstance(requireContext())
         workManager?.enqueueUniquePeriodicWork(
Index: ../../.idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../../.idea/misc.xml b/../../.idea/misc.xml
--- a/../../.idea/misc.xml	(revision fef057f5fc91674e99d142fb37e781e5ea4564a1)
+++ b/../../.idea/misc.xml	(date 1706830988090)
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ProjectRootManager">
     <output url="file://$PROJECT_DIR$/out" />
